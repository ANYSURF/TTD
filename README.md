# TTD - этап2

## roadmap
Создать в github репозитории файл readme.md в этот файл, используя markdown выпишите свои выводы и структуру, которую вы поняли и сами для себя сформировали. 

## ссылки для облегчения учебы:
https://telegra.ph/Links-08-28-58

## Практическое задание
скомпилировать этот контракт: https://github.com/broxus/ton-contracts/blob/master/contracts/wallets/Account.sol и изучить его

## Изучить это: 
 https://docs.ton.dev/86757ecb2/p/950f8a-write-smart-contract-in-solidity

## Дополнительная информация по солидити, для подкрепления
https://docs.soliditylang.org/en/latest/cheatsheet.html

https://docs.soliditylang.org/en/latest/style-guide.html

https://docs.soliditylang.org/en/latest/structure-of-a-contract.html

# Структура данных

## Массив и связанный список

На основе массива создаётся структура данных - стек или полное двоичное дерево. На основе полного двоичного дерева создаются двоичная куча. Назначение - распараллеливане данных.

На основе связанного списка создаётся очередь  или двоичное дерево поиска. (AWL-, красное- и чёрное- дерево). Назначение - упорядовочиние данных.

## Хеш таблицы на основе объединения массивов и связанных списков

позволяют создать префиксное дерево способое компактно хранить в памяти обьекты - например строки. Строки хранятся в массиве. 

Работа с массивами строк, храняшимися в опеределюнной кодировке (big & little endian) в бинарном виде, в массивах, через адресацию памяти и битовые манипуляции создаёт битовый вектор.

Обьеденив битовый вектор, массив и связанный список через хэш таблицу получим граф - основу для любого серьёзного программирования.

# Скорость структур данных и математика

Оценка сложности - требует знаний о функциях, логоритмах, математической индукции, арифмитической и геометрической прогрессии, BigO и теории вероятности (комбинаторики).

# Навыки программирования

Почему и когда память работает как стек или куча

Почему работает математическая индукция

Навыки комбинаторики

Рекурсия

Динамическое программирование

Алгоритмы (Сортировка и двоичный поиск)

# Компилятoры 

https://docs.soliditylang.org/en/latest/grammar.html

Синтактический анализ

Парсинг

Семантический анализ

Оптимизация

Генерация кода

# Типы Solidity

https://docs.soliditylang.org/en/latest/types.html#value-types

## Булевыe (Логиiческий тип дaнных)

! (logical negation)

&& (logical conjunction, “and”)

|| (logical disjunction, “or”)

== (equality)

!= (inequality)

## Целые числа

intN, uintN - N разрядность 8,16,32...256

## Числа с фиксированной точкой

fixedMxN, ufixedMxN - М количество битов, N количество десятичных

## Адрес

address: Содержит 20-байтовое значение (размер адреса Ethereum).
address payable: То же, что и address, но с дополнительными элементами transferи send.

### Члены Адресов

<address>.balance( uint256)

баланс адреса

<address>.code( )bytes memory

код по адресу (может быть пустым)

<address>.codehash( bytes32)

хеш-код адреса

<address payable>.transfer(uint256 amount)

отправить заданное количество Wei на адрес , возвращается в случае неудачи, пересылает стипендию на газ в размере 2300, не регулируется

<address payable>.send(uint256 amount) returns (bool)

отправить указанное количество Wei на адрес , возврат falseв случае неудачи, пересылка 2300 стипендий на бензин, не регулируется

<address>.call(bytes memory) returns (bool, bytes memory)

выдает низкоуровневую информацию CALLс заданной полезной нагрузкой, возвращает условие успеха и данные, пересылает весь доступный газ, настраивается

<address>.delegatecall(bytes memory) returns (bool, bytes memory)

выдает низкоуровневую информацию DELEGATECALLс заданной полезной нагрузкой, возвращает условие успеха и данные, пересылает весь доступный газ, настраивается

<address>.staticcall(bytes memory) returns (bool, bytes memory)

выдает низкоуровневую информацию STATICCALLс заданной полезной нагрузкой, возвращает условие успеха и данные, пересылает весь доступный газ, настраивается

## Массивы байтов фиксированного размера

bytesI - I размер 1..32

.length дает фиксированную длину массива байтов (только для чтения).

## Байтовый массив динамического размера

bytes, string

## Адресные литералы

Шестнадцатеричные литералы, которые проходят проверку контрольной суммы адреса

## Рациональные и целочисленные литералы

## Строковые литералы и типы

## Литералы Юникода

## Шестнадцатеричные литералы

Перечисления

Типы функций

## Операторы:

Сравнения: <=, <, ==, !=, >=, >(вычисляться bool)

Арифметические операторы: +, -, Унарный -, *, /, %(по модулю)

Битовые операторы: &, |, ^(побитовое исключающее или), ~(побитовое отрицание)

Операторы сдвига: <<(сдвиг влево), >>(сдвиг вправо)

Доступ к индексу: если x имеет тип bytesI, то x[k]for возвращает -й байт (только для чтения).0 <= k < Ik



