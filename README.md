# TTD - этап 3

Создать фронт с помощью этого тутариала 
https://nodeschool.io/#workshopper-list

## Разобраться с флагами.
описания флагов есть тут https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/API.md#addresstransfer


Создание и деплой контракта ZombieFactory.sol чтобы применить на практике урок https://cryptozombies.io/ru/lesson/1 

 ## Подготовить среду установив Node.js


npm install -g tondev

tondev sol update

tondev sol version

tondev sol set --compiler 0.50.0 --linker 0.13.66 --stdlib 0.50.0

tondev network default se

tondev signer add giver_keys 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3

tondev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver_keys

tondev signer generate owner_keys

tondev signer default owner_keys


## взять или пересоздать контракт ZombieFactory.sol


tondev sol compile ZombieFactory.sol
 
tondev se start

tondev contract deploy ZombieFactory --value 1000000000

## запись в контракт:

tondev contract run ZombieFactory

 — имеет смыл только createZombie
 
чтение контракта:

tondev contract run-local ZombieFactory zombieCount

tondev contract run-local ZombieFactory getZombieDna

tondev contract run-local ZombieFactory getZombieName

## Ссылки:

https://hackmd.io/LLwxyC0rRYOJ9ZXptAzKxA?view

https://www.youtube.com/watch?v=ngD88UraMmU&list=PLPj4C8ti8UaSPAP6afsy0wQ53lihBT5l1

Вопросы и ответы:

Есть ли различие в ТОНе между storage / memory? - во фритон нет memory, всё storage

Обязателен ли tvm.accept() при вызове callback? -  tvm.accept обязателен для внешних сообщений но не обязателен для внутренних, к которым прикладывается value. в ссылке выше есть описание этой функции.

# TTD - этап2

## roadmap

Создать в github репозитории файл readme.md в этот файл, используя markdown выпишите свои выводы и структуру, которую вы поняли и сами для себя сформировали.

## Обучающая игра

<https://cryptozombies.io/ru>

КриптоЗомби - интерактивная школа программирования. Это игра больше к эфиру, но там семантика схожа с той что у нас на фритон в компиляторе..

## ссылки для облегчения учебы

<https://telegra.ph/Links-08-28-58>

<https://github.com/tonlabs/TON-Solidity-Compiler/tree/master/compiler/docs>

<https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/compiler/docs/style-guide.rst>

## Практическое задание

скомпилировать этот контракт: <https://github.com/broxus/ton-contracts/blob/master/contracts/wallets/Account.sol> и изучить его

## Изучить это

 <https://docs.ton.dev/86757ecb2/p/950f8a-write-smart-contract-in-solidity>

## Дополнительная информация по солидити, для подкрепления

<https://docs.soliditylang.org/en/latest/cheatsheet.html>

<https://docs.soliditylang.org/en/latest/style-guide.html>

<https://docs.soliditylang.org/en/latest/structure-of-a-contract.html>

# Структура данных

## Массив и связанный список

На основе массива создаётся структура данных - стек или полное двоичное дерево. На основе полного двоичного дерева создаются двоичная куча. Назначение - распараллеливане данных.

На основе связанного списка создаётся очередь  или двоичное дерево поиска. (AWL-, красное- и чёрное- дерево). Назначение - упорядовочиние данных.

## Хеш таблицы на основе объединения массивов и связанных списков

позволяют создать префиксное дерево способое компактно хранить в памяти обьекты - например строки. Строки хранятся в массиве.

Работа с массивами строк, храняшимися в опеределюнной кодировке (big & little endian) в бинарном виде, в массивах, через адресацию памяти и битовые манипуляции создаёт битовый вектор.

Обьеденив битовый вектор, массив и связанный список через хэш таблицу получим граф - основу для любого серьёзного программирования.

# Скорость структур данных и математика

Оценка сложности - требует знаний о функциях, логоритмах, математической индукции, арифмитической и геометрической прогрессии, BigO и теории вероятности (комбинаторики).

# Навыки программирования

Почему и когда память работает как стек или куча

Почему работает математическая индукция

Навыки комбинаторики

Рекурсия

Динамическое программирование

Алгоритмы (Сортировка и двоичный поиск)

# Компилятoры

<https://docs.soliditylang.org/en/latest/grammar.html>

Синтактический анализ

Парсинг

Семантический анализ

Оптимизация

Генерация кода

# Типы Solidity

<https://docs.soliditylang.org/en/latest/types.html#value-types>

Список типов значений поддерживаемых TVM:

Integer - 257-битные целые числа со знаком, представляющие целые числа в
диапазон

Cell - Ячейка TVM состоит не более чем из 1023 бит данных и не более
максимум четыре ссылки на другие ячейки. Все постоянные данные (включая TVM
code) в блокчейне TON представлен в виде набора TVM
клетки

Tuple - упорядоченный набор до 255 компонентов, имеющих произвольные типы значений, возможно, разные. Может использоваться для представления непостоянных значений произвольных алгебраических типов данных.

Null - Тип с ровно одним значением ⊥, используемый для представления пустого
списки, пустые ветви бинарных деревьев, отсутствие возвращаемого значения в некоторых
ситуации и так далее.

Slice - Срез ячейки TVM, или для краткости, представляет собой непрерывную «субячейку».
существующей ячейки, содержащей некоторые ее биты данных и некоторые из ее
использованная литература. По сути, срез это доступное только для чтения представление для подъячейки ячейки. Срезы используются для распаковки данных, ранее сохраненных (или сериализованных) в ячейка или дерево ячеек.

Builder - Строитель ячеек TVM, или, для краткости, строитель, является «неполным»
ячейка, которая поддерживает быстрые операции добавления битовых строк и ссылок на ячейки в ее конце. Строители используются для упаковки (или сериализации) данных.
из вершины стека в новые ячейки (например, перед их переносом
в постоянное хранилище).

Continuation - представляет собой «токен выполнения» для TVM, который может быть вызванным (выполненным) позже. Таким образом, он обобщает адреса функций.
(т.е. указатели на функции и ссылки), адреса возврата подпрограмм,
адреса указателей инструкций, адреса обработчиков исключений, замыкания,
частичные приложения, анонимные функции и т. д.

## Булевыe (Логиiческий тип дaнных)

! (logical negation)

&& (logical conjunction, “and”)

|| (logical disjunction, “or”)

== (equality)

!= (inequality)

## Целые числа

intN, uintN - N разрядность 8,16,32...256

## Числа с фиксированной точкой

fixedMxN, ufixedMxN - М количество битов, N количество десятичных

## Адрес

address: Содержит 20-байтовое значение (размер адреса Ethereum).
address payable: То же, что и address, но с дополнительными элементами transferи send.

### Члены Адресов

<address>.balance( uint256)

баланс адреса

<address>.code( )bytes memory

код по адресу (может быть пустым)

<address>.codehash( bytes32)

хеш-код адреса

<address payable>.transfer(uint256 amount)

отправить заданное количество Wei на адрес , возвращается в случае неудачи, пересылает стипендию на газ в размере 2300, не регулируется

<address payable>.send(uint256 amount) returns (bool)

отправить указанное количество Wei на адрес , возврат falseв случае неудачи, пересылка 2300 стипендий на бензин, не регулируется

<address>.call(bytes memory) returns (bool, bytes memory)

выдает низкоуровневую информацию CALLс заданной полезной нагрузкой, возвращает условие успеха и данные, пересылает весь доступный газ, настраивается

<address>.delegatecall(bytes memory) returns (bool, bytes memory)

выдает низкоуровневую информацию DELEGATECALLс заданной полезной нагрузкой, возвращает условие успеха и данные, пересылает весь доступный газ, настраивается

<address>.staticcall(bytes memory) returns (bool, bytes memory)

выдает низкоуровневую информацию STATICCALLс заданной полезной нагрузкой, возвращает условие успеха и данные, пересылает весь доступный газ, настраивается

## Массивы байтов фиксированного размера

bytesI - I размер 1..32

.length дает фиксированную длину массива байтов (только для чтения).

## Байтовый массив динамического размера

bytes, string

## Адресные литералы

Шестнадцатеричные литералы, которые проходят проверку контрольной суммы адреса

## Рациональные и целочисленные литералы

## Строковые литералы и типы

## Литералы Юникода

## Шестнадцатеричные литералы

Перечисления

Типы функций

## Операторы

Сравнения: <=, <, ==, !=, >=, >(вычисляться bool)

Арифметические операторы: +, -, Унарный -, *, /, %(по модулю)

Битовые операторы: &, |, ^(побитовое исключающее или), ~(побитовое отрицание)

Операторы сдвига: <<(сдвиг влево), >>(сдвиг вправо)

Доступ к индексу: если x имеет тип bytesI, то x[k]for возвращает -й байт (только для чтения).0 <= k < Ik
